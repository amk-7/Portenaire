\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\title{DOCUMENTATION DOCKER \textbf{Docker}}
\begin{document}
\maketitle


\section{Généralités}
Dans cette première partie, nous allons découvrir les \textbf{conteneurs} ainsi que 
Docker. Mais avant cela, nous allons revenir sur quelque notions importantes :
\begin{itemize}
\item[•] comprendre la notion de \textbf{machine virtuelle};
\item[•] comprendre la notion de \textbf{conteneur};
\item[•] \textbf{pourquoi} utiliser les conteneurs ?
\end{itemize} 
\subsection{Machine virtuelle (VM)}
Utiliser une machine virtuelle c'est faire de la \textbf{virtualisation lourde}. Pourquoi car
nous recréons un système complet (avec ses propres ressources) dans notre système.

\textbf{L'isolation avec le système hôte est donc totale}; cependant cela nous apporte 
plusieurs contraintes et avantages.
\begin{itemize}
\item[] Contraint.
\begin{itemize}
\item[•] Une machine virtuelle prend du \textbf{temps} à démarrer;
\item[•] Une machine virtuelle \textbf{réserve les ressources (CPU/RAM)} sur le système 
hôte.
\end{itemize}
\item[] Avantages.
\begin{itemize}
\item[•] Une machine virtuelle est totalement \textbf{isolée} du système hôte;
\item[•] Les ressource attribuées à une machine virtuelle lui sont totalement \textbf{réservées}.
\item[•] Vous pouvez installer \textbf{différents OS} (Linux, Windows, etc.).
\end{itemize}

\begin{figure}
\centering
\includegraphics[scale=0.3]{img/vm.png}
\caption{Fonctionnement d'une machine virtuelle}
\label{Tux}
\end{figure}

Mais il arrive souvent que l'application qu'elle fait tourner ne consomme pas l'ensemble 
des ressources disponibles sur la machine virtuelle. Alors est né un nouveau système de 
virtualisation plus léger : les \textbf{conteneurs}.
\end{itemize}
\subsection{Conteneur}
Un conteneur Linux est un \textbf{processus} ou un ensemble de processus isolés du reste du
système, tout en étant \textbf{légers}.\\
Le conteneur permet de faire de la \textbf{virtualisation légère}, c'est à dire qu'il ne virtualise pas les ressources, il ne crée qu'une \textbf{isolation des processus}. Le conteneur partage donc les ressources avec le système hôte.\\

\textbf{Attention}, les conteneurs existent depuis plus longtemps que \textbf{Docker}.
\textbf{OpenVZ} ou \textbf{LXC} sont des technologies de conteneur qui existent depuis de
nombreuses années.

Les conteneurs, au sens d'OpenVZ et LXC, apportent une \textbf{isolation importante des processus systèmes} ; cependant, les ressources CPU, RAM et disque sont totalement
partagées avec l'ensemble du système. Les conteneurs partagent entre eux le kernel Linux;
ainsi, il n'est pas possible de faire fonctionner un système Windows ou BSD dans celui-ci.

\begin{figure}
\centering
\includegraphics[scale=0.3]{img/container_vs_vm.png}
\caption{Fonctionnement d'une machine virtuelle}
\label{Tux}
\end{figure}

Maintenant voyons quelque avantages des conteneurs.
\begin{itemize}
\item \textbf{Ne réservez que les ressources nécessaires}
Une autre différence importante avec les machines virtuelles est qu'un conteneur \textbf{ne réserve pas} la quantité de CPU, RAM et disque attribuée auprès du système hôte. Ainsi, nous pouvons allouer 16 Go de RAM à notre conteneur, mais si celui-ci n'utilise que 2 Go, le reste ne sera pas verrouillé.
\item \textbf{ Démarrez rapidement vos conteneurs}
Les conteneurs n'ayant pas besoin d'une virtualisation des ressources mais seulement d'une isolation des processus, ils peuvent \textbf{démarrer beaucoup plus rapidement} et plus fréquemment qu'une machine virtuelle sur nos serveurs hôtes, et ainsi réduire encore un peu les frais de l'infrastructure.
\item \textbf{Donnez plus d'autonomie à vos développeurs}
En dehors de la question pécuniaire, il y a aussi la possibilité de faire tourner des conteneurs sur le poste des développeurs, et ainsi de réduire les différences entre la "sainte" production, et l'environnement local sur le poste des développeurs.
\end{itemize}

\subsection{Pourquoi utiliser des conteneurs ?}
Les conteneurs permettent de \textbf{réduire les coûts}, d'augmenter la \textbf{densité de l'infrastructure}, tout en améliorant le cycle de déploiement.

Grace à leur capacité de démarrer plus rapidement, les conteneurs sont souvent utilisés en 
production pour ajouter des ressources disponibles, et ainsi répondre à des besoins de mise
à l'échelle ou de scalabilité. Mais ils répondent aussi à des besoins de préproduction;
en étant légers et rapides au démarrage, il permettent de créer des environnements dynamique et ainsi de répondre à des besoins métier.

\subsection{Exemple d'équation entre Administrateur système et Développeurs}
L'une des équation possible entre administrateur système (admin) et développeurs (dev)
pourrait être la suivante :
\begin{verbatim}
Administrateur système = Garant de la stabilité de la sécurité des systèmes informatiques
Développeurs = Créateurs de nouvelles fonctionnalité et applications
\end{verbatim}
\begin{itemize}
\item[•] \textbf{Administrateur système} est responsable de maintenir la stabilité et la
sécurité des systèmes informatique en s'assurant que tous les logiciels et configurations 
fonctionnent correctement et que les données soit protégées contre les menaces de sécurité.
\item[•] Les \textbf{Développeurs}, quant à eux, sont responsable de créer de nouvelles 
fonctionnalités et applications pour répondre aux besoins de l'entreprise et des 
utilisateur.
\end{itemize}

Ces deux rôles sont complémentaires et interdépendants. Les développeurs ont besoin d'un environnement de développement stable et sécurisé pour travailler efficacement, tandis que l'administrateur système a besoin de comprendre les besoins des développeurs pour configurer les systèmes en conséquence. Ensemble, ils travaillent pour assurer le bon fonctionnement des systèmes informatiques de l'entreprise.

\subsection{Docker préambule}
Docker est une plateforme de conteneurisation qui permet d'emballer et d'exécuter des applications dans des conteneurs isolés.
\subsubsection{Une petite histoire}
Docker a été créé pour les besoins d'une société de Platform as a Service (PaaS) appelée \textbf{DotCloud}. Finalement, en mars 2013, l'entreprise a créé une nouvelle structure nommée \textbf{Docker Inc} et a placé en open source son produit \textbf{Docker}.

\subsubsection{Objectifs}
Docker apporte une notion importante dans le monde du conteneur. Dans la vision Docker, un conteneur ne doit faire tourner qu'\textbf{un seul processus}. Ainsi, dans le cas d'une stack LAMP (Linux, Apache, MySQL, PHP), nous devons créer \textbf{3 conteneurs} différents, un pour Apache, un pour MySQL et un dernier pour PHP. Alors que dans un conteneur LXC ou OpenVZ, nous aurions fait tourner l'ensemble des 3 services dans un seul et unique conteneur.

\subsubsection{Pourquoi utiliser Docker ?}
Docker répond à une problématique forte dans le monde du développement.
Prenons un exemple : vous avez développé votre projet de Twitter Lite en local. Tout fonctionne bien, mais au moment de mettre en production, vous vous rendez compte que vous ne savez pas comment \textbf{déployer votre projet}. Un autre exemple : vous êtes dans une équipe de 10 personnes et chacun utilise un OS différent (Ubuntu, macOS, Windows, CentOS, etc.). Comment faire pour avoir \textbf{un environnement unifié et fonctionnel} chez l'ensemble des développeurs ?

Docker répond à ces problématiques en créant des conteneurs. Grâce à Docker, vous n'aurez plus de problème de différence d'environnement, et votre code marchera partout !

\subsection{Comprendre la terminologie de Docker avant de se lancer !}
Avant de se lancer dans l'utilisation de Docker, il est important de comprendre la terminologie suivante :
\begin{itemize}
\item[•] Image : une image Docker est un paquet de base qui contient tout le nécessaire pour exécuter une application, y compris le code source, les dépendances, les bibliothèques et les fichiers de configuration.
\item[•] Conteneur : un conteneur Docker est une instance d'une image qui s'exécute de manière isolée dans un environnement de conteneur. Un conteneur peut être considéré comme une boîte virtuelle qui contient tout ce dont l'application a besoin pour s'exécuter.
\item[•] Dockerfile : un Dockerfile est un fichier de configuration qui permet de créer une image Docker personnalisée. Il contient les instructions nécessaires pour créer une image Docker à partir d'une base existante.
\item[•] Docker Compose : Docker Compose est un outil qui permet de définir et de gérer des applications multi-conteneurs. Il permet de définir plusieurs conteneurs et leurs dépendances dans un fichier de configuration unique.
\item[•] Registre : un registre Docker est un référentiel centralisé qui permet de stocker et de distribuer des images Docker. Docker Hub est le registre public officiel de Docker.
\end{itemize}

En comprenant ces termes de base, vous serez mieux préparé pour travailler avec Docker et comprendre comment créer, déployer et gérer des conteneurs Docker
    
\section{Docker}
\subsection{Installer Docker}
Docker Inc distribue 3 versions de Docker différentes :
\begin{itemize}
\item[•] Docker Community Edition (Linux seulement) ;
\item[•] Docker Desktop (Mac ou Windows) ;
\item[•] Docker Enterprise (Linux seulement).
\end{itemize}
Docker Desktop et Docker Community Edition (CE) sont deux versions de Docker gratuites. Avec les deux solutions, vous aurez un Docker fonctionnel sur votre ordinateur.

Si vous êtes sous Windows ou macOS, utilisez Docker Desktop qui va créer pour vous l'ensemble des services nécessaires au bon fonctionnement de Docker.

Si vous êtes sous Linux, prenez la version Community Edition (CE) ; vous utiliserez aussi cette version pour vos serveurs.

La version Docker Enterprise ne ressemble pas du tout aux versions Desktop et CE. Celle-ci répond à des besoins plus poussés des entreprises, et propose une interface de gestion d'infrastructures sous Docker. Cette version est soumise à une licence fournie par Docker Inc.

\textbf{NB:} Pour installer docker sur Mac ou Windows rendez vous ici.
Dans le cas de Linux, vous devez utiliser les commandes suivante.
\begin{verbatim}
sudo apt-get install docker.io
install docker-ce == moteur
docker-ce-cli == pour communiquer avec le moteur
containerd.io == gérer l'exécution de conteneurs.
docker-buildx-plugin == pour builder nos images
 docker-compose-plugin
\end{verbatim}

Après ou avant l'installation de docker il est conseiller de créer votre compte au
niveau du docker hub

\section{Lancer notre premier conteneur}
Dans cette partie, je vous propose de \textbf{prendre en main Docker}. Nous allons 
commencer par découvrir l'\textbf{interface en ligne de commande}, qui nous permet
de discuter avec le \textbf{daemon Docker} installé précédemment. D'ici la fin de cette partie, vous serez capable de \textbf{lancer et gérer vos conteneurs}. Mais commençons dans ce chapitre par comprendre ce qu'est le \textbf{Docker Hub}, puis nous lancerons notre \textbf{premier conteneur}.

\subsection{Le Docker Hub}
Avant de démarrer votre premier conteneur Docker, rappelez-vous quand vous avez créé votre compte sur le Docker Hub pour télécharger votre version de Docker. Celui-ci est aussi 
\textbf{la registry officielle de Docker}.\\

Une \textbf{registry} est un logiciel qui permet de partager des images à d'autres personnes. C’est un composant majeur dans l’écosystème Docker, car il permet :

\begin{itemize}
\item à des développeurs de distribuer des images prêtes à l’emploi et de les versionner avec un système de tags ;
\item à des outils d’intégration en continu de jouer une suite de tests, sans avoir besoin d’autre chose que de Docker ;
\item à des systèmes automatisés de déployer ces applications sur vos environnements de développement et de production.
\end{itemize}

\subsection{Démarrez votre premier conteneur Docker}
Pour démarrer votre premier conteneur, vous devez utiliser la commande :
\begin{verbatim}
docker run hello-world
\end{verbatim}
\begin{center}
\includegraphics[scale=0.3]{img/p_conteneur.png}
\end{center}
Quand vous utilisez cette commande, le \textbf{daemon Docker} va chercher si l'image \textit{hello-world} est \textbf{disponible en local}. Dans le cas contraire, il va la \textbf{récupérer sur la registry Docker officielle.}

Dans notre cas, le conteneur a démarré, puis affiché du contenu, et il a fini par s'arrêter. Si vous souhaitez \textbf{que votre conteneur reste allumé jusqu’à l'arrêt du service qu'il contient}, vous devez ajouter l’argument \textit{- -detach (-d)} . Celui-ci permet de ne pas rester attaché au conteneur, et donc de pouvoir lancer plusieurs conteneurs. Nous allons voir dans la section suivante comment utiliser l’argument -d.

\subsection{Démarrez un serveur Nginx avec un conteneur Docker}
vous savez lancer un conteneur, et vous avez compris les actions effectuées par le daemon Docker lors de l'utilisation de la commande docker run.

Maintenant, nous allons aller plus loin avec celui-ci. Nous allons lancer un conteneur qui démarre un serveur Nginx en utilisant deux options (\textbf{-d} et \textbf{-p}) :
\begin{verbatim}
docker run -d -p 8080:80 nginx 
\end{verbatim}  .
Dans cette commande, nous avons utilisé deux options :
\begin{itemize}
\item -d pour détacher le conteneur du processus principal de la console. Il vous permet de continuer à utiliser la console pendant que votre conteneur tourne sur un autre processus ;
\item -p pour définir l'utilisation de ports. Dans notre cas, nous lui avons demandé de transférer le trafic du port 8080 vers le port 80 du conteneur.
\end{itemize}
    Ainsi, en vous rendant sur l'adresse  http://127.0.0.1:8080, vous aurez la page par défaut de Nginx.\\
Vous pourriez aussi avoir besoin de "rentrer" dans votre conteneur Docker pour pouvoir y effectuer des actions. Pour cela, vous devez utiliser la commande \\
\textbf{docker exec -ti ID\_RETOURNÉ\_LORS\_DU\_DOCKER\_RUN bash}  . Dans cette commande, l'argument \textit{-ti} permet d'avoir un shell bash pleinement opérationnel. Une fois que vous êtes dans votre conteneur, vous pouvez vous rendre, via la commande \textbf{cd /usr/share/nginx/html}  , dans le répertoire où se trouve le fichier index.html  , pour modifier son contenu et voir le résultat en direct à l'adresse http://127.0.0.1:8080.

\subsection{Récupérez une image depuis le docker Hub}
Vous pouvez aussi avoir besoin de récupérer des images sur le Docker Hub sans pour autant lancer de conteneur. Pour cela, vous avez besoin de lancer la commande suivante :

\begin{verbatim}
docker pull hello-world

Using default tag: latest

latest: Pulling from library/hello-world

Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535

Status: Image is up to date for hello-world:latest
\end{verbatim}

En lançant cette commande, vous téléchargez une image directement depuis le Docker Hub, et vous la stockez en local sur votre ordinateur.

\textbf{NB : } Généralement le pull d'une image peut prendre, beaucoup de seconde voir minute.

\subsection{Quelques commandes}
\begin{itemize}
\item[•] \textbf{docker images} ou \textbf{docker image ls} : Affiche la liste de toute les
images.
\begin{center}
\includegraphics[scale=0.5]{img/docker_images.png}
\end{center}
On peut facilement repérer les métadonnées suivantes :
\begin{verbatim}
REPOSITORY                  TAG       IMAGE ID       CREATED       SIZE
\end{verbatim}
\begin{itemize}
\item \textbf{REPOSITORY} désigne souvent le nom de l'image.
\item \textbf{TAG} sa version.
\item \textbf{IMAGE ID} son identifiant (unique).
\item \textbf{CREATED} l'heur à la quelle elle à été créer 
\item \textbf{SIZE} L'espace mémoire qu'elle occupe.
\end{itemize}
\item[•] \textbf{docker ps} ou \textbf{docker container ls} : Affiche la liste de tous les
conteneurs dans l'état \textbf{RUNING}. pour afficher tous les conteneurs vous allez 
devoir spécifier l'option \textbf{-a} pour \textit{all}.
\item[•] \textbf{docker stop ID\_RETOURNÉ\_LORS\_DU\_DOCKER\_RUN} permet d'arrêter un conteneur.
\item[•] \textbf{docker rm ID\_RETOURNÉ\_LORS\_DU\_DOCKER\_RUN} ou \textbf{docker rm NOM\_CONTENEURE} permet de supprimer un conteneur.\\
\textbf{NB : } Cela ne fonctionnera si et seulement si le conteneur est stoppé. Pour 
contourner ce problème vous pouvez utiliser l'option -f (pour \textit{force}) comme ceci
\textbf{docker rm -f ID\_RETOURNÉ\_LORS\_DU\_DOCKER\_RUN} 
\item[•] \textbf{docker image rm IMAGE\_ID} ou \textbf{docker rmi IMAGE\_ID} permet 
de supprimez une image. Vous pouvez aussi utiliser ici l'option -f.
\item[•] \textbf{docker inspect ID\_RETOURNÉ\_LORS\_DU\_DOCKER\_RUN} pour avoir
des détails plus détaillé sur le conteneur.
\end{itemize}

\subsection{Comment nettoyer son système docker}
Après avoir fait de nombreux tests sur votre ordinateur, vous pouvez avoir besoin de faire un peu de ménage. Pour cela, vous pouvez supprimer manuellement l'ensemble des ressources dans Docker.\\
Ou vous pouvez laisser faire Docker pour qu'il fasse lui-même le ménage. Voici la commande que vous devez utiliser pour faire le ménage :  \textbf{docker system prune}.\\
\begin{verbatim}
 docker system prune
WARNING! This will remove:
- all stopped containers
- all networks not used by at least one container
- all dangling images
- all dangling build cache
Are you sure you want to continue? [y/N] y
Deleted Containers:
941b8955b4fd8988fefe2aa91c7eb501f2d4f8c56bf4718fea8ed50904104745
a96e73c623fb6530ab41db6a82aca7017d54a99590f0b45eb6bf934ef8e4d3ed

Deleted Images:
deleted: sha256:797a90d1aff81492851a11445989155ace5f87a05379a0fd7342da4c4516663e
deleted: sha256:c5c8911bd17751bd631ad7ed00203ba2dcb79a64316e14ea95a9edeb735ca3ea

Total reclaimed space: 21.08MB
\end{verbatim}
Celle-ci va supprimer les données suivantes :
\begin{itemize}
\item[•] l'ensemble des conteneurs Docker qui ne sont pas en status running ;
\item[•] l'ensemble des réseaux créés par Docker qui ne sont pas utilisés par au moins un conteneur ;
\item[•] l'ensemble des images Docker non utilisées ;
\item[•] l'ensemble des caches utilisés pour la création d'images Docker.
\end{itemize}

\section{Les Volumes}
Lorsque vous créer un conteneur, par défaut ses données ne sont pas
persistant. C'est à dire que si vous supprimé un conteneur ses
données disparaîtrons aussi. Pour éviter que cela ne se produise
docker à mis en place la notion de volume.\\
\textbf{Docker volume} est un \textbf{mécanisme de fichiers géré
par Docker permettant de sauvegardé des données générées lors de 
l'exécution d'un conteneur}. Il permet également de monter les données dont le conteneur a besoin à l'intérieur de ce dernier lors
de son lancement.\\
Mais avant de voir \textbf{Docker volume} nous allons voir les
volumes persistant.

\subsection{Les volumes persistant}
Vous vous souvenez du serveur nginx que nous avions créer ? si 
vous l'avez déjà supprimé, je vous pris de le recréer. Voici
la commande si vous l'avez oublié
\begin{verbatim}
docker run -d --name seveur -p 8080:80 nginx
\end{verbatim}
Une fois créer entrer dans le conteneur en utilisant la commande suivante :
\begin{verbatim}
docker exec -it serveur
\end{verbatim}
Rendez-vous ensuite dans le fichier index.html et modifier le à votre guise. Mais souvenez vous il n'y a aucun éditeur installé par défaut.
\begin{center}
\includegraphics[scale=0.5]{img/volume_persistant_1.png}
\end{center}
Voici le résultat.
\begin{center}
\includegraphics[scale=0.3]{img/volume_persistant.png}
\end{center}
Maintenant supprimé votre conteneur et recréer le.
\begin{verbatim}
docker rm -f serveur
docker run -d --name serveur -p 8080:80 nginx
\end{verbatim}
Que se passe t-il ?
Vos modifications n'ont pas été pris en compte et vous voyez la
page par défaut de nginx ! 
Pour régler ce problème nous allons utiliser un volume. créer un 
répertoire nommé \textbf{public\_html}. Créez s'y le fichier
\textbf{index.html}(mettez y ce que vous voulez).
Comme la redirection de port, nous allons 
faire le mappage de répertoire en disant que le répertoire 
\textbf{/urs/share/nginx/html} doit correspondre au répertoire
\textbf{public\_html}. Vous comprenez donc pourquoi nous devons 
créer nous même le fichier \textbf{index.html}. Créez maintenant
notre conteneur.
\begin{verbatim}
docker run -d --name serveur -p 8001:80 
-v /home/amk/IFNTI/DAP/DAP_L3/UELIBRE/
Test/test/public_html/:/usr/share/nginx/html/ nginx 
\end{verbatim}
\begin{center}
\includegraphics[scale=0.3]{img/volume_mount.png}
\end{center}
Supprimer votre conteneur et recréer le que se passe t'il ?
Vos données sont devenue persistant ! C'est cool n'est pas.
\begin{center}
\includegraphics[scale=0.3]{img/test_volume.png}
\end{center}
Dans la suit nous allons voir docker volume.

\subsection{Docker volume}
Docker volume nous permet de créer des volumes à volonté. Par
défaut les volumes que nous créer on leurs point de montage au
niveau de la machine hôte dans le répertoire \textbf{/var/lib/
docker/volumes/}.\\
Pour voir tous ce qu'on peut faire avec docker volume (et cela vaut
pour toute les commande) vous n'avez
qu'a taper \textbf{docker volume} dans votre terminal vous verrez
ça.
\begin{verbatim}
amk@amk:~/IFNTI/DAP/DAP_L3/UELIBRE/Test/test$ docker volume 

Usage:  docker volume COMMAND

Manage volumes

Commands:
  create      Create a volume
  inspect     Display detailed information on one or more volumes
  ls          List volumes
  prune       Remove all unused local volumes
  rm          Remove one or more volumes

Run 'docker volume COMMAND --help' for more information on a command.
amk@amk:~/IFNTI/DAP/DAP_L3/UELIBRE/Test/test$ 

\end{verbatim}
Nous allons créer un volume nommé monvolume voici la commande.
\begin{verbatim}
amk@amk:~/IFNTI/DAP/DAP_L3/UELIBRE/Test/test$ docker volume create monvolume
monvolume
amk@amk:~/IFNTI/DAP/DAP_L3/UELIBRE/Test/test$ 
\end{verbatim}
Pour avoir plus de détails sur un volume vous utiliser la commande
inspect comme ceci.
\begin{verbatim}
amk@amk:~/IFNTI/DAP/DAP_L3/UELIBRE/Test/test$ docker volume inspect monvolume 
[
    {
        "CreatedAt": "2023-01-25T10:07:02Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/monvolume/_data",
        "Name": "monvolume",
        "Options": {},
        "Scope": "local"
    }
]
amk@amk:~/IFNTI/DAP/DAP_L3/UELIBRE/Test/test$ 
\end{verbatim}
Maintenant nous allons utiliser notre volume sur un conteneur en
utilisant l'option \textbf{--mount}
\begin{verbatim}
docker run -d --name web -p 8001:80 --mount 
source=monvolume,target=/usr/share/nginx/html nginx
\end{verbatim}
Voici le résultat:
\begin{center}
\includegraphics[scale=0.3]{img/docker_volume_init.png}
\end{center}
Vous pouvez modifier le contenue du fichier index.php comme ceci:
\begin{verbatim}
sudo vim /var/lib/docker/volumes/monvolume/_data/index.html
\end{verbatim}
Voici le résultat:
\begin{center}
\includegraphics[scale=0.3]{img/docker_volume_n.png}
\end{center}
Maintenant que vous êtes maître amusé vous avec la commande
\textbf{docker volume}.

\section{Dockerfile : Créer une image.}
Vous savez maintenant utiliser l'interface de commande de Docker et récupérer des images depuis le Docker Hub. Mais comment créer votre propre image ?\\
Dans cette partie, nous allons créer ensemble une image Docker, dans laquelle nous allons installer nginx.\\
Pour cela, nous allons créer un fichier nommé \textbf{"Dockerfile"} (fichier de configuration). Dans ce fichier Dockerfile, vous allez trouver l'ensemble de la recette décrivant l'image Docker dont vous avez besoin pour votre projet.\\
Intérêts de \textbf{Dockerfile}.
\textit{À titre de comparaison, vous pouvez voir le Dockerfile comme l'équivalent d'un fichier package.json en Node.js, ou composer.json en PHP. } \\
Chaque instruction que nous allons donner dans notre Dockerfile va créer une nouvelle layer correspondant à chaque étape de la construction de l'image.
Notre but est de limiter le nombre e layers, pour que l'image soit la plus légère et performante possible.

Voici quelles que closes d'un \textbf{Dockerfile}:
\begin{itemize}
\item[•] \textbf{RUN} : lancement de commande (apt...).
\item[•] \textbf{ENV} : variable d'environnement.
\item[•] \textbf{EXPOSE} : exposition de port.
\item[•] \textbf{VOLUME} : définition de volumes
\item[•] \textbf{COPY} : cp entre host et conteneur
\item[•] \textbf{ENTRYPOINT} : processus maître.
\item[•] \textbf{...} : ...
\end{itemize}

Voici le contenue de notre Dockerfile.

\begin{verbatim}
FROM nginx:latest
WORKDIR /usr/share/nginx/html/
RUN rm index.html
COPY . .
\end{verbatim}

Dans cette image :
\begin{itemize}
\item on part de la dernière version du serveur nginx,
\item on définit le répertoire de travail,
\item on supprime le fichier index.html
\item on copie notre fichier index.html.
\end{itemize} 

\textbf{NB}: \\
Il est capitale de nommé votre fichier \textbf{"Dockerfile"} tel quel.
Il est très important de toujours \textbf{partir d'une base} (FROM ...).
un fichier Dockerfile ne peut qu'avoir qu'une base.

Maintenant que vous savez pourquoi et comment créer un dockerfile il nous reste plus
qu'a l'exécuté. Pour lancer une image on utilise la commande suivante.

\textbf{docker build -t site\_html:v1.0 .}

Cette commande signifie que nous souhaitons créer une image dont le nom vaut \textit{site\_html}
et la version \textit{v1.0} en se servant du Dockerfile se trouvant dans notre répertoire 
courant (si vous ne spécifiez pas de version elle sera à \textbf{latest} pour dernière version).
si vous faite \textit{docker images} vous pouvez comme moi voir votre image .\\
::::::img\\
On peut aussi faire \textbf{docker history site\_html:v1.0} pour voir en détails les étapes de 
la création de notre image.\\

On peut donc créer un conteneur à partir de notre image en utilisant la commande suivante:
\textbf{docker run -d - -name website site\_html:v1.0}

\section{Les Layers}
Les layers ou couches en français interviennent dans la création d'une image et d'un conteneur. Avec docker on peut distinguer deux types de couches :
\begin{itemize}
\item ceux en lecture seul (images).
\item et ceux en lecture-écriture (conteneurs).
\end{itemize} 
les images comme les conteneurs peuvent se partager au moins une couche.
:::::Expérience des couches xavki +
:::::Expérience de couche partagé.

\subsection{Le cache docker}
But du cache : 
\begin{itemize}
\item construire plus vite les images
\item démarrer plus vite les conteneurs
\item stocker des images légères
\item partager des couches/layers
\end{itemize}
Démonstration : \\
\subsubsection{Lancer deux fois de suite une image (using cache)}
Ici nous allons essayer de lancer deux fois de suite une même image. Voici 
le contenue su docker file contenue dans cette image.
\begin{verbatim}
FROM alpine:latest

LABEL maintener="amk"

RUN apk add vim
\end{verbatim}
lorsqu'on lance pour la première fois cette image avec la commande :
\begin{verbatim}
docker build -t test_vim .
\end{verbatim}
On peut remarqué qu'il n'a pas utilisation du cache.
\begin{center}
\includegraphics[scale=0.5]{img/test_vim.png}
\end{center}
Par contre si on relance une deuxième fois l'image là il y-a utilisation du cache.
\begin{center}
\includegraphics[scale=0.5]{img/test_vim_cache.png}
\end{center}
L'utilisation du cache se fait même si on change le nom de l'image comme ceci :
\begin{verbatim}
docker build -t test_vim2
\end{verbatim}
\begin{center}
\includegraphics[scale=0.5]{img/test_vim3.png}
\end{center}
\textbf{Conclusion } : Une couche n'est télécharger que si elle n'existe pas.
\subsubsection{Ne pas cacher (--no-cache)}
On peut vouloir ne pas utiliser le cache lors du build d'une image. Dans ce cas notre image
sera comme ceci.
\begin{verbatim}
FROM alpine:latest

LABEL maintener="amk"

RUN apk add --no-cache vim
\end{verbatim}
\begin{center}
\includegraphics[scale=0.5]{img/test_vim_no_cache.png}
\end{center}
Donc on peut remarquer l'utilisation du cache au niveau de toute les couches sauf à la 
couche 3 c'est normale car nous n'avons spécifier l'utilisation du cache.
On peut aussi utiliser le --no-cache comme ceci :
\begin{verbatim}
docker build --no-cache -t test_vim2
\end{verbatim}
Mais là c'est l'intégralité du Dockerfile sur le quelle on n'appliquera pas de cache.

\textbf{NB } : l'ordre des éléments comptes. Il est important de mettre des instructions
caché en haut et ceux non caché tous en bas.
Exemple : Lancer successivement les Dockerfile suivant.\\
\textbf{Dockerfile 1}
\begin{verbatim}
--------------------------
FROM alpine:latest

LABEL maintener="amk"

ENV myvariable toto

RUN apk add  vim
--------------------------
\end{verbatim} 
\begin{verbatim}
docker build -t test
\end{verbatim}
\begin{verbatim}
docker build -t test1
\end{verbatim}
\textbf{Dockerfile 2}
\begin{verbatim}
--------------------------
FROM alpine:latest

LABEL maintener="amk"

ENV myvariable titi

RUN apk add  vim
--------------------------
\end{verbatim} 
\begin{verbatim}
docker build -t test
\end{verbatim}
\textbf{Dockerfile 3}
\begin{verbatim}
--------------------------
FROM alpine:latest

LABEL maintener="amk"

RUN apk add  vim

ENV myvariable toto
--------------------------
\end{verbatim} 
\begin{verbatim}
docker build -t test
\end{verbatim}

\section{Les Réseaux}
Le principale réseaux c'est le \textbf{Bridge} qu'on appelle le \textbf{Docker 0}.
Il à une adresse par défaut qui est le
\textbf{172.17.0.0/16}. Il permet la communication entre différent conteneurs et couvre 
la plus part des besoins en matière de réseau. Mais attention dans la manipulation des 
réseaux avec docker il est recommandé d'utiliser les nom des conteneur car les adresse 
ip ne sont pas fixe.

\subsection{ping sur le docker 0}
Avant de lancer un ping sur le docker 0 nous allons devoir d'abord créer un conteneur comme
ceci :
\begin{verbatim}
docker run -tid --name conteneur1 alpine
\end{verbatim}
Ensuit on rentre dans le conteneur en utilisant la commande suivante:
\begin{verbatim}
docker exec -ti conteneur1 sh 
\end{verbatim}
Une fois dans le conteneur on peut consulter son adresse ip avec la commande \textbf{ip a}.
\begin{center}
\includegraphics[scale=0.5]{img/ip_a_c1.png}
\end{center}
On peut remarqué que notre adresse ip commence à deux (2) au lieu de commencer à un (1).
Pourquoi ? car c'est le docker 0 est la première machine dans le \textbf{bridge}. On
peut lancer un ping vers ce docker 0 et ça marche car le conteneur est dans le même 
réseau que le docker 0.
\begin{center}
\includegraphics[scale=0.5]{img/ping_c1.png}
\end{center}

\subsection{Personnalisation du bridge --net}
Docker nous donne la possibilité de créer nos propres réseaux. Avant de créer notre premier 
réseau on va déjà regardé quelle sont les réseaux existant pour le moment. Pour le
faire lancé la commande :  \textbf{docker network ls} vous devriez avoir 
quelle que chose de similaire sans le \textbf{domalik\_default}.
\begin{center}
\includegraphics[scale=0.5]{img/d_networks.png}
\end{center}
Vous pouvez remarqué que les types de réseaux sont le \textbf{bridge}, le \textbf{host} et 
le \textbf{none}. Nous verrons ici comment créer des réseaux bridge.
Voici un exemple de réseau( de type bridge) dont le non est \textbf{mon\_reseau}et le sous
réseau est \textbf{172.30.0.0/16} on utilise
la commande
suivante :\\
\begin{verbatim}
docker network create -d bridge --subnet 172.30.0.0/16 mon_reseau
\end{verbatim}
Si vous fait un \textbf{docker network ls} vous verrez que le \textbf{mon\_reseau} à bien
été créé. En voici la preuve:
\begin{center}
\includegraphics[scale=0.5]{img/my_network.png}
\end{center}
Pour faire un petit test de réseau on peut essayé de créer trois conteneur :
\begin{itemize}
\item deux première conteneur (conteneur1 et conteneur2) qui seront dans le même réseau et
\item un troisième conteneur qui sera dans le bridge par défaut.
\end{itemize}
Nous essayerons de lancer des ping de la manière suivante:
\begin{verbatim}
conteneur1   ------> conteneur2
conteneur2   ------> conteneur1
conteneur3   ------> conteneur1
\end{verbatim}
Sans plus tarder, créons les trois conteneurs :
\begin{verbatim}
docker run -itd --name conteneur1 --network mon_reseau alpine
docker run -itd --name conteneur2 --network mon_reseau alpine
docker run -itd --name conteneur3 alpine
\end{verbatim}
\begin{center}
\includegraphics[scale=0.5]{img/ip_a_all_c.png}
\end{center}

\subsubsection{ping conteneur1 vs conteneur2}
\begin{center}
\includegraphics[scale=0.5]{img/ping_c1_c2.png}
\end{center}
Le ping marche car le conteneur1 et le conteneur2 sont dans le même sous réseaux.
\subsubsection{ping conteneur2 vs conteneur1}
\begin{center}
\includegraphics[scale=0.5]{img/ping_c2_c1.png}
\end{center}
Le ping marche car le conteneur1 et le conteneur2 sont dans le même sous réseaux.
\subsubsection{ping conteneur3 vs conteneur1}
\begin{center}
\includegraphics[scale=0.5]{img/ping_c3_c1.png}
\end{center}
Le ping ne marche pas car le conteneur1 et le conteneur3 ne sont pas dans le même sous
 réseaux.
 
\subsection{Autre cas --net}
\begin{itemize}
\item \textbf{--net : none} Pour spécifier que le conteneur n'a aucune ouverture réseau 
(cas particulier).
\item \textbf{--net : host} Son ouverture réseau ne correspond qu'a l'accès au host.
\item \textbf{--net : container:<nomconteneur>} Ouverture réseau à un conteneur particulier.
\end{itemize}

\subsection{Autre cas --link}
\textbf{--link : container:<nomconteneur>} Ouverture réseau à un conteneur particulier. Mais vas aller compléter le \textbf{/etc/hosts} du conteneur.\\
Pour tester ça : on vas créer deux conteneurs. Le conteneur1 et le conteneur2 qui
utilise le réseau du conteneur2
\begin{verbatim}
docker run -itd --name conteneur1 alpine
docker run -itd --name conteneur2 --link conteneur1 alpine
\end{verbatim}
\begin{center}
\includegraphics[scale=0.5]{img/link_c1.png}
\end{center}

\subsection{Et en plus ...}
\begin{itemize}
\item \textbf{--add-host <nomhost>:ip} : complète le /etc/hosts.
\item \textbf{--dns} : ajoute les ip de serveurs dns.
\end{itemize}

Test : ici nous avons créer le conteneur1 en précisant l'option --add-host pour cela 
demander à un de vos camarade de vous donner son adresse ip ou si vous aviez une deuxième
machine prenez son adresse ip. Dans mon cas l'adresse ip de mon camarade est le 
\textit{192.168.60.180}(Il est important que votre host soit aussi dans le même sous réseau). 
\begin{center}
\includegraphics[scale=0.5]{img/add_host.png}
\end{center}
\begin{center}
\includegraphics[scale=0.5]{img/add_host_2.png}
\end{center}

\section{Docker compose}
Docker compose est un orchestrateur de conteneur. Il permet de gérer plusieurs conteneur à 
la fois. Ainsi il permet de simplifier nos déploiements sur de multiple environnement.
Docker compose est un outil écrit en python qui permet de décrire, dans un fichier
\textbf{YAML}, plusieurs conteneurs comme un ensemble de service.

\subsection{Installation de docker compose.}
Normalement si vous avez installer docker avec notre ligne de commande, docker compose
serait déjà installé si ce n'est pas le cas alors exécuter la commande suivante:
\begin{verbatim}
sudo curl -L "https://github.com/docker/compose/
releases/download/1.23.2/docker-compose-
$(uname -s)-$(uname -m)" -o /usr/bin/docker-compose && 
sudo chmod +x /usr/bin/docker-compose
\end{verbatim}
Puis :\\
\begin{verbatim}
docker-compose --version
\end{verbatim}

\subsection{Le CLI de Docker Compose}
Pour utiliser \textbf{le CLI (Command Line Interface)} de Docker Compose, nous avons besoin d'un fichier \textbf{docker-compose.yml} 
que nous allons créer dans l'exemple ci dessous ! Mais avant de le créer, nous allons commencer par découvrir ensemble l'interface 
en ligne de commande (CLI) qui nous permet d'utiliser le fichier docker-compose.yml.\\
\textbf{Le CLI de Docker Compose et celui de Docker sont très proches}. Par exemple, si vous souhaitez récupérer l'ensemble des images décrites 
dans votre fichier docker-compose.yml et les télécharger depuis le Docker Hub, vous devez faire un docker-compose pull. 
Du côté de Docker, la commande serait un docker pull.\\

\textit{Le fait que les deux interfaces en ligne de commande soient très similaires nous évite d'apprendre un nouveau CLI. Si vous connaissez celui de Docker, vous savez globalement utiliser celui de Docker Compose !}\\

Cependant, nous allons quand même voir ensemble les principales commandes que vous pourriez avoir besoin d'utiliser et de connaître pour votre utilisation de Docker Compose.

\subsection{Démarrer une stack Docker Compose}
Si vous souhaitez lancer la création de l'ensemble des conteneurs, vous devez lancer la commande \textbf{docker-compose up} (pour rappel, vous faites un \textbf{docker run} pour lancer un seul conteneur). Vous pouvez ajouter l’argument \textbf{-d} pour faire tourner les conteneurs en tâche de fond.\\

Nous appelons \textbf{stack} un ensemble de conteneurs Docker lancés via un seul et unique fichier Docker Compose.\\

\subsection{Voir le statut d'une stack Docker Compose}
Après avoir démarré une \textbf{stack} Docker Compose, vous aurez certainement besoin de voir si l'ensemble des conteneurs sont bien dans un état fonctionnel, et prêts à rendre un service.\\
Pour cela, vous allez utiliser la commande \textbf{docker-compose ps} qui vous affichera le retour suivant :

\begin{verbatim}
NAME                COMMAND                  SERVICE             STATUS              PORTS
ou
no configuration file provided: not found  
\end{verbatim}

\subsection{Voir les logs d'une stack Docker Compose}
Votre stack Docker Compose est maintenant fonctionnelle, et l'ensemble des services répondent bien ; mais vous pourriez avoir besoin de voir les logs de vos conteneurs. Pour cela, vous devez utiliser la commande \textbf{docker-compose logs -f --tail 5}.\\

Celle-ci permet de voir l'ensemble des logs sur les différents conteneurs de façon continue, tout en limitant l'affichage aux 5 premières lignes.\\

Ainsi, si nos conteneurs fonctionnent depuis longtemps, nous n'aurons pas à attendre plusieurs secondes, ni à voir de nombreux logs qui ne nous intéressent pas.\\

\subsection{Arrêter une stack Docker Compose}
Si vous souhaitez arrêter une stack Docker Compose, vous devez utiliser la commande \textbf{docker-compose stop}. Cependant, celle-ci ne supprimera pas les différentes ressources créées par votre stack.\\
Ainsi, si vous lancez à nouveau un \textbf{docker-compose up -d}, l'ensemble de votre stack sera tout de suite à nouveau fonctionnel.\\

Si vous souhaitez supprimer l'ensemble de la stack Docker Compose, vous devez utiliser la commande \textbf{docker-compose down} qui détruira l'ensemble des ressources créées.\\

\subsection{Valider une stack Docker Compose}
Lors de l'écriture d'un fichier docker-compose, nous ne sommes pas à l’abri d'une erreur. Pour éviter au maximum cela, vous devez utiliser la commande \textbf{docker-compose config} qui vous permettra de valider la syntaxe de votre fichier, et ainsi d'être certain de son bon fonctionnement.\\

Si nous créons une erreur dans notre stack, en remplaçant "image" par "images", par exemple, nous aurons le résultat suivant :

\begin{verbatim}
$ docker-compose config

ERROR: The Compose file './docker-compose.yml' is invalid because:

Unsupported config option for services.db: 'images'
\end{verbatim}

\subsection{En résumé}
Vous connaissez maintenant les commandes principales pour utiliser une \textbf{stack Docker Compose}. Voici les commandes les plus importantes :
\begin{itemize}
\item \textbf{docker-compose up -d} vous permettra de démarrer l'ensemble des conteneurs en arrière-plan ;
\item \textbf{docker-compose ps} vous permettra de voir le statut de l'ensemble de votre stack ;
\item \textbf{docker-compose logs -f --tail 5} vous permettra d'afficher les logs de votre stack ;
\item \textbf{docker-compose stop} vous permettra d'arrêter l'ensemble des services d'une stack ;
\item \textbf{docker-compose down} vous permettra de détruire l'ensemble des ressources d'une stack ;
\item \textbf{docker-compose config} vous permettra de valider la syntaxe de votre fichier docker-compose.yml.
\end{itemize}

\section{Créez un fichier docker-compose pour orchestrer vos conteneurs}
Nous avons vu précédent comment utiliser l'interface en ligne de commande de Docker Compose; vous allez maintenant apprendre à créer un fichier docker-compose.yml. \\
\textbf{Sujet :} \\
Vous avez un nouveau projet de site avec WordPress, et vous souhaitez simplifier la gestion de l'infrastructure. Vous devez maintenant réaliser un déploiement en production, où l'ensemble des composants sont dans des conteneurs Docker. Pour cela, vous allez avoir besoin de plusieurs composants :
\begin{itemize}
\item une base de données MySQL ;
\item le système de fichiers WordPress.
\end{itemize}
Voici le diagramme de déploiement correspondant.\\
:::::Image::::::\\

Vous devez commencer par créer un fichier \textbf{docker-compose.yml} à la racine de votre projet. Dans celui-ci, nous allons décrire l'ensemble des ressources et services nécessaires à la réalisation de votre POC (Proof Of Concept).\\
\subsection{Décrivez votre premier service : db}
\subsubsection{Définissez la version de Docker Compose}
Un fichier docker-compose.yml commence toujours par les informations suivantes :
\begin{verbatim}
version: '3'
\end{verbatim}
L'argument version permet de spécifier à Docker Compose quelle version on souhaite utiliser, et donc d'utiliser ou pas certaines versions. Dans notre cas, nous utiliserons la version 3, qui est actuellement la version la plus utilisée.\\

\subsubsection{Déclarez le premier service et son image}
Nous allons maintenant déclarer notre premier service, et donc créer notre \textbf{stack WordPress} !\\
L'ensemble des conteneurs qui doivent être créés doivent être définis sous l'argument \textbf{services}. Chaque conteneur commence avec un nom qui lui est propre ; dans notre cas, notre premier conteneur se nommera \textbf{db}.

\begin{verbatim}
services:

  db:

    image: mysql:5.7
\end{verbatim}

Puis, vous devez \textbf{décrire votre conteneur}; dans notre cas, nous utilisons l’argument \textbf{image} qui nous permet de définir l'image Docker que nous souhaitons utiliser.\\

Nous aurions pu aussi utiliser l’argument \textbf{build} en lui spécifiant le chemin vers notre fichier \textbf{Dockerfile} ; ainsi, lors de l’exécution de Docker Compose, il aurait construit le conteneur via le Dockerfile avant de l’exécuter.

\subsubsection{Définissez le volume pour faire persister vos données}
\begin{verbatim}
services:

  db:

    image: mysql:5.7

    volumes:

      - db_data:/var/lib/mysql
\end{verbatim}

Pour rappel, nous avons vu précédemment que les conteneurs Docker ne sont pas faits pour faire fonctionner des services \textbf{stateful}, et une base de données est par définition un service \textbf{stateful}. Alors vous allez utiliser l'argument volumes qui vous permet de stocker l'ensemble du contenu du dossier /var/lib/mysql dans un disque persistant. Et donc, de pouvoir garder les données en local sur notre host comme nous l'avons vue dans
la section VOLUME.

Cette description est présente grâce à la ligne \textbf{db\_data:/var/lib/mysql}. db\_data est un volume créé par Docker directement, qui permet d'écrire les données sur le disque hôte sans spécifier l'emplacement exact. Vous auriez pu aussi faire un /data/mysql:/var/lib/mysql qui serait aussi fonctionnel.
\subsubsection{Définissez la politique de redémarrage du conteneur}
\begin{verbatim}
services:

  db:

    image: mysql:5.7

    volumes:

      - db_data:/var/lib/mysql

    restart: always
\end{verbatim}
Un conteneur étant par définition \textbf{monoprocessus}, s'il rencontre une erreur fatale, il peut être amené à s'arrêter. Dans notre cas, si le serveur MySQL s'arrête, celui-ci redémarrera automatiquement grâce à l'argument \textbf{restart: always}.
\subsubsection{Définissez les variables d'environnement}
\begin{verbatim}
services:

  db:

    image: mysql:5.7

    volumes:

      - db_data:/var/lib/mysql

    restart: always

    environment:

      MYSQL_ROOT_PASSWORD: somewordpress

      MYSQL_DATABASE: wordpress

      MYSQL_USER: wordpress

      MYSQL_PASSWORD: wordpress
\end{verbatim}

L'image MySQL fournie dispose de plusieurs variables d'environnement que vous pouvez utiliser ; dans notre cas, nous allons donner au conteneur les valeurs des différents mots de passe et utilisateurs qui doivent exister sur cette base. Quand vous souhaitez donner des variables d'environnement à un conteneur, vous devez utiliser l'argument \textbf{environment}, comme nous l'avons utilisé dans le fichier docker-compose.yml ci-dessus.
\subsection{Décrivez votre second service : WordPress}
Dans le second service, nous créons un conteneur qui contiendra le nécessaire pour faire fonctionner votre site avec WordPress. Cela nous permet d'introduire deux arguments supplémentaires.

\begin{verbatim}
services:

  wordpress:

    depends_on:

      - db

    image: wordpress:latest

    ports:

      - "8000:80"

    restart: always

    environment:

      WORDPRESS_DB_HOST: db:3306

      WORDPRESS_DB_USER: wordpress

      WORDPRESS_DB_PASSWORD: wordpress

      WORDPRESS_DB_NAME: wordpress
\end{verbatim}

Le premier argument, \textbf{depends\_on}, nous permet de créer une dépendance entre deux conteneurs. Ainsi, Docker démarrera le service db avant de démarrer le service WordPress. Ce qui est un comportement souhaitable, car WordPress dépend de la base de données pour fonctionner correctement.

Le second argument, \textbf{ports}, permet de dire à Docker Compose qu'on veut exposer un port de notre machine hôte vers notre conteneur, et ainsi le rendre accessible depuis l'extérieur.

Voici le fichier \textbf{docker-compose.yml} dans sa version finale :

\begin{verbatim}
version: '3'

services:

  db:

    image: mysql:5.7

    volumes:

      - db_data:/var/lib/mysql

    restart: always

    environment:

      MYSQL_ROOT_PASSWORD: somewordpress

      MYSQL_DATABASE: wordpress

      MYSQL_USER: wordpress

      MYSQL_PASSWORD: wordpress

    

  wordpress:

    depends_on:

      - db

    image: wordpress:latest

    ports:

      - "8000:80"

    restart: always

    environment:

      WORDPRESS_DB_HOST: db:3306

      WORDPRESS_DB_USER: wordpress

      WORDPRESS_DB_PASSWORD: wordpress

      WORDPRESS_DB_NAME: wordpress


volumes:

  db_data: {}
\end{verbatim}

\subsection{Lancez votre stack Docker Compose}

Quand vous lancerez vos conteneurs avec la commande \textbf{docker-compose up -d}  , vous devriez avoir le résultat suivant :

\begin{verbatim}
$ docker-compose up -d

Creating network "my_wordpress_default" with the default driver

Pulling db (mysql:5.7)...

5.7: Pulling from library/mysql

efd26ecc9548: Pull complete

a3ed95caeb02: Pull complete

...

Digest: sha256:34a0aca88e85f2efa5edff1cea77cf5d3147ad93545dbec99cfe705b03c520de

Status: Downloaded newer image for mysql:5.7

Pulling wordpress (wordpress:latest)...

latest: Pulling from library/wordpress

efd26ecc9548: Already exists

a3ed95caeb02: Pull complete

589a9d9a7c64: Pull complete

...

Digest: sha256:ed28506ae44d5def89075fd5c01456610cd6c64006addfe5210b8c675881aff6

Status: Downloaded newer image for wordpress:latest

Creating my_wordpress_db_1

Creating my_wordpress_wordpress_1
\end{verbatim}

Lors de l'exécution de cette commande, Docker Compose commence par vérifier si nous disposons bien en local des images nécessaires au lancement des stacks. Dans le cas contraire, il les télécharge depuis une registry, ou les build via un \textbf{docker build  .}\\

Puis celui-ci lance les deux conteneurs sur votre système ; dans notre cas, vous pourrez voir le résultat en vous ouvrant l'URL suivante dans votre navigateur : \textbf{ http://127.0.0.1:8000.}\\
::::::IMAGE:::::::
\subsection{En résumé}
Vous savez maintenant utiliser les commandes de base de Docker Compose, et créer un fichier docker-compose.yml pour orchestrer vos conteneurs Docker.\\

Pour rappel, voici les arguments que nous avons pu voir dans ce chapitre :
\begin{itemize}
\item \textbf{image} qui permet de spécifier l'image source pour le conteneur ;
\item \textbf{build} qui permet de spécifier le Dockerfile source pour créer l'image du conteneur ;
\item \textbf{volume} qui permet de spécifier les points de montage entre le système hôte et les conteneurs ;
\item \textbf{restart} qui permet de définir le comportement du conteneur en cas d'arrêt du processus ;
\item \textbf{environment} qui permet de définir les variables d’environnement ;
\item \textbf{depends\_on} qui permet de dire que le conteneur dépend d'un autre conteneur ;
\item \textbf{ports} qui permet de définir les ports disponibles entre la machine host et le conteneur.
\end{itemize}

\end{document}



